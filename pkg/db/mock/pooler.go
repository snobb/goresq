// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/snobb/goresq/pkg/db"
	"sync"
)

// Ensure, that PoolerMock does implement db.Pooler.
// If this is not the case, regenerate this file with moq.
var _ db.Pooler = &PoolerMock{}

// PoolerMock is a mock implementation of db.Pooler.
//
// 	func TestSomethingThatUsesPooler(t *testing.T) {
//
// 		// make and configure a mocked db.Pooler
// 		mockedPooler := &PoolerMock{
// 			CloseFunc: func() error {
// 				panic("mock out the Close method")
// 			},
// 			ConnFunc: func() (db.Conn, error) {
// 				panic("mock out the Conn method")
// 			},
// 		}
//
// 		// use mockedPooler in code that requires db.Pooler
// 		// and then make assertions.
//
// 	}
type PoolerMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ConnFunc mocks the Conn method.
	ConnFunc func() (db.Conn, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Conn holds details about calls to the Conn method.
		Conn []struct {
		}
	}
	lockClose sync.RWMutex
	lockConn  sync.RWMutex
}

// Close calls CloseFunc.
func (mock *PoolerMock) Close() error {
	if mock.CloseFunc == nil {
		panic("PoolerMock.CloseFunc: method is nil but Pooler.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedPooler.CloseCalls())
func (mock *PoolerMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Conn calls ConnFunc.
func (mock *PoolerMock) Conn() (db.Conn, error) {
	if mock.ConnFunc == nil {
		panic("PoolerMock.ConnFunc: method is nil but Pooler.Conn was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConn.Lock()
	mock.calls.Conn = append(mock.calls.Conn, callInfo)
	mock.lockConn.Unlock()
	return mock.ConnFunc()
}

// ConnCalls gets all the calls that were made to Conn.
// Check the length with:
//     len(mockedPooler.ConnCalls())
func (mock *PoolerMock) ConnCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConn.RLock()
	calls = mock.calls.Conn
	mock.lockConn.RUnlock()
	return calls
}

// Ensure, that ConnMock does implement db.Conn.
// If this is not the case, regenerate this file with moq.
var _ db.Conn = &ConnMock{}

// ConnMock is a mock implementation of db.Conn.
//
// 	func TestSomethingThatUsesConn(t *testing.T) {
//
// 		// make and configure a mocked db.Conn
// 		mockedConn := &ConnMock{
// 			CloseFunc: func() error {
// 				panic("mock out the Close method")
// 			},
// 			DoFunc: func(commandName string, args ...interface{}) (interface{}, error) {
// 				panic("mock out the Do method")
// 			},
// 			ErrFunc: func() error {
// 				panic("mock out the Err method")
// 			},
// 			FlushFunc: func() error {
// 				panic("mock out the Flush method")
// 			},
// 			ReceiveFunc: func() (interface{}, error) {
// 				panic("mock out the Receive method")
// 			},
// 			SendFunc: func(commandName string, args ...interface{}) error {
// 				panic("mock out the Send method")
// 			},
// 		}
//
// 		// use mockedConn in code that requires db.Conn
// 		// and then make assertions.
//
// 	}
type ConnMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DoFunc mocks the Do method.
	DoFunc func(commandName string, args ...interface{}) (interface{}, error)

	// ErrFunc mocks the Err method.
	ErrFunc func() error

	// FlushFunc mocks the Flush method.
	FlushFunc func() error

	// ReceiveFunc mocks the Receive method.
	ReceiveFunc func() (interface{}, error)

	// SendFunc mocks the Send method.
	SendFunc func(commandName string, args ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Do holds details about calls to the Do method.
		Do []struct {
			// CommandName is the commandName argument value.
			CommandName string
			// Args is the args argument value.
			Args []interface{}
		}
		// Err holds details about calls to the Err method.
		Err []struct {
		}
		// Flush holds details about calls to the Flush method.
		Flush []struct {
		}
		// Receive holds details about calls to the Receive method.
		Receive []struct {
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// CommandName is the commandName argument value.
			CommandName string
			// Args is the args argument value.
			Args []interface{}
		}
	}
	lockClose   sync.RWMutex
	lockDo      sync.RWMutex
	lockErr     sync.RWMutex
	lockFlush   sync.RWMutex
	lockReceive sync.RWMutex
	lockSend    sync.RWMutex
}

// Close calls CloseFunc.
func (mock *ConnMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ConnMock.CloseFunc: method is nil but Conn.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedConn.CloseCalls())
func (mock *ConnMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Do calls DoFunc.
func (mock *ConnMock) Do(commandName string, args ...interface{}) (interface{}, error) {
	if mock.DoFunc == nil {
		panic("ConnMock.DoFunc: method is nil but Conn.Do was just called")
	}
	callInfo := struct {
		CommandName string
		Args        []interface{}
	}{
		CommandName: commandName,
		Args:        args,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(commandName, args...)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//     len(mockedConn.DoCalls())
func (mock *ConnMock) DoCalls() []struct {
	CommandName string
	Args        []interface{}
} {
	var calls []struct {
		CommandName string
		Args        []interface{}
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// Err calls ErrFunc.
func (mock *ConnMock) Err() error {
	if mock.ErrFunc == nil {
		panic("ConnMock.ErrFunc: method is nil but Conn.Err was just called")
	}
	callInfo := struct {
	}{}
	mock.lockErr.Lock()
	mock.calls.Err = append(mock.calls.Err, callInfo)
	mock.lockErr.Unlock()
	return mock.ErrFunc()
}

// ErrCalls gets all the calls that were made to Err.
// Check the length with:
//     len(mockedConn.ErrCalls())
func (mock *ConnMock) ErrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockErr.RLock()
	calls = mock.calls.Err
	mock.lockErr.RUnlock()
	return calls
}

// Flush calls FlushFunc.
func (mock *ConnMock) Flush() error {
	if mock.FlushFunc == nil {
		panic("ConnMock.FlushFunc: method is nil but Conn.Flush was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFlush.Lock()
	mock.calls.Flush = append(mock.calls.Flush, callInfo)
	mock.lockFlush.Unlock()
	return mock.FlushFunc()
}

// FlushCalls gets all the calls that were made to Flush.
// Check the length with:
//     len(mockedConn.FlushCalls())
func (mock *ConnMock) FlushCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFlush.RLock()
	calls = mock.calls.Flush
	mock.lockFlush.RUnlock()
	return calls
}

// Receive calls ReceiveFunc.
func (mock *ConnMock) Receive() (interface{}, error) {
	if mock.ReceiveFunc == nil {
		panic("ConnMock.ReceiveFunc: method is nil but Conn.Receive was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReceive.Lock()
	mock.calls.Receive = append(mock.calls.Receive, callInfo)
	mock.lockReceive.Unlock()
	return mock.ReceiveFunc()
}

// ReceiveCalls gets all the calls that were made to Receive.
// Check the length with:
//     len(mockedConn.ReceiveCalls())
func (mock *ConnMock) ReceiveCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReceive.RLock()
	calls = mock.calls.Receive
	mock.lockReceive.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *ConnMock) Send(commandName string, args ...interface{}) error {
	if mock.SendFunc == nil {
		panic("ConnMock.SendFunc: method is nil but Conn.Send was just called")
	}
	callInfo := struct {
		CommandName string
		Args        []interface{}
	}{
		CommandName: commandName,
		Args:        args,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(commandName, args...)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedConn.SendCalls())
func (mock *ConnMock) SendCalls() []struct {
	CommandName string
	Args        []interface{}
} {
	var calls []struct {
		CommandName string
		Args        []interface{}
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}
