// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/snobb/goresq/pkg/db"
	"sync"
	"time"
)

// Ensure, that AccessorMock does implement db.Accessor.
// If this is not the case, regenerate this file with moq.
var _ db.Accessor = &AccessorMock{}

// AccessorMock is a mock implementation of db.Accessor.
//
//	func TestSomethingThatUsesAccessor(t *testing.T) {
//
//		// make and configure a mocked db.Accessor
//		mockedAccessor := &AccessorMock{
//			DecrFunc: func(ctx context.Context, key string) (int64, error) {
//				panic("mock out the Decr method")
//			},
//			DelFunc: func(ctx context.Context, keys ...string) (int64, error) {
//				panic("mock out the Del method")
//			},
//			DoFunc: func(ctx context.Context, args ...any) (any, error) {
//				panic("mock out the Do method")
//			},
//			GetFunc: func(ctx context.Context, key string) (string, error) {
//				panic("mock out the Get method")
//			},
//			IncrFunc: func(ctx context.Context, key string) (int64, error) {
//				panic("mock out the Incr method")
//			},
//			LPopFunc: func(ctx context.Context, key string) (any, error) {
//				panic("mock out the LPop method")
//			},
//			LPushFunc: func(ctx context.Context, key string, value any) (any, error) {
//				panic("mock out the LPush method")
//			},
//			RPopFunc: func(ctx context.Context, key string) (any, error) {
//				panic("mock out the RPop method")
//			},
//			RPushFunc: func(ctx context.Context, key string, value any) (any, error) {
//				panic("mock out the RPush method")
//			},
//			SAddFunc: func(ctx context.Context, key string, members ...any) (int64, error) {
//				panic("mock out the SAdd method")
//			},
//			SRemFunc: func(ctx context.Context, key string, members ...any) (int64, error) {
//				panic("mock out the SRem method")
//			},
//			SetFunc: func(ctx context.Context, key string, value any, exp time.Duration) (string, error) {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedAccessor in code that requires db.Accessor
//		// and then make assertions.
//
//	}
type AccessorMock struct {
	// DecrFunc mocks the Decr method.
	DecrFunc func(ctx context.Context, key string) (int64, error)

	// DelFunc mocks the Del method.
	DelFunc func(ctx context.Context, keys ...string) (int64, error)

	// DoFunc mocks the Do method.
	DoFunc func(ctx context.Context, args ...any) (any, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, key string) (string, error)

	// IncrFunc mocks the Incr method.
	IncrFunc func(ctx context.Context, key string) (int64, error)

	// LPopFunc mocks the LPop method.
	LPopFunc func(ctx context.Context, key string) (any, error)

	// LPushFunc mocks the LPush method.
	LPushFunc func(ctx context.Context, key string, value any) (any, error)

	// RPopFunc mocks the RPop method.
	RPopFunc func(ctx context.Context, key string) (any, error)

	// RPushFunc mocks the RPush method.
	RPushFunc func(ctx context.Context, key string, value any) (any, error)

	// SAddFunc mocks the SAdd method.
	SAddFunc func(ctx context.Context, key string, members ...any) (int64, error)

	// SRemFunc mocks the SRem method.
	SRemFunc func(ctx context.Context, key string, members ...any) (int64, error)

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, key string, value any, exp time.Duration) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Decr holds details about calls to the Decr method.
		Decr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Del holds details about calls to the Del method.
		Del []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// Do holds details about calls to the Do method.
		Do []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args []any
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Incr holds details about calls to the Incr method.
		Incr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// LPop holds details about calls to the LPop method.
		LPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// LPush holds details about calls to the LPush method.
		LPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value any
		}
		// RPop holds details about calls to the RPop method.
		RPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// RPush holds details about calls to the RPush method.
		RPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value any
		}
		// SAdd holds details about calls to the SAdd method.
		SAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []any
		}
		// SRem holds details about calls to the SRem method.
		SRem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []any
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value any
			// Exp is the exp argument value.
			Exp time.Duration
		}
	}
	lockDecr  sync.RWMutex
	lockDel   sync.RWMutex
	lockDo    sync.RWMutex
	lockGet   sync.RWMutex
	lockIncr  sync.RWMutex
	lockLPop  sync.RWMutex
	lockLPush sync.RWMutex
	lockRPop  sync.RWMutex
	lockRPush sync.RWMutex
	lockSAdd  sync.RWMutex
	lockSRem  sync.RWMutex
	lockSet   sync.RWMutex
}

// Decr calls DecrFunc.
func (mock *AccessorMock) Decr(ctx context.Context, key string) (int64, error) {
	if mock.DecrFunc == nil {
		panic("AccessorMock.DecrFunc: method is nil but Accessor.Decr was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDecr.Lock()
	mock.calls.Decr = append(mock.calls.Decr, callInfo)
	mock.lockDecr.Unlock()
	return mock.DecrFunc(ctx, key)
}

// DecrCalls gets all the calls that were made to Decr.
// Check the length with:
//
//	len(mockedAccessor.DecrCalls())
func (mock *AccessorMock) DecrCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDecr.RLock()
	calls = mock.calls.Decr
	mock.lockDecr.RUnlock()
	return calls
}

// Del calls DelFunc.
func (mock *AccessorMock) Del(ctx context.Context, keys ...string) (int64, error) {
	if mock.DelFunc == nil {
		panic("AccessorMock.DelFunc: method is nil but Accessor.Del was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockDel.Lock()
	mock.calls.Del = append(mock.calls.Del, callInfo)
	mock.lockDel.Unlock()
	return mock.DelFunc(ctx, keys...)
}

// DelCalls gets all the calls that were made to Del.
// Check the length with:
//
//	len(mockedAccessor.DelCalls())
func (mock *AccessorMock) DelCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockDel.RLock()
	calls = mock.calls.Del
	mock.lockDel.RUnlock()
	return calls
}

// Do calls DoFunc.
func (mock *AccessorMock) Do(ctx context.Context, args ...any) (any, error) {
	if mock.DoFunc == nil {
		panic("AccessorMock.DoFunc: method is nil but Accessor.Do was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args []any
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(ctx, args...)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//	len(mockedAccessor.DoCalls())
func (mock *AccessorMock) DoCalls() []struct {
	Ctx  context.Context
	Args []any
} {
	var calls []struct {
		Ctx  context.Context
		Args []any
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *AccessorMock) Get(ctx context.Context, key string) (string, error) {
	if mock.GetFunc == nil {
		panic("AccessorMock.GetFunc: method is nil but Accessor.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedAccessor.GetCalls())
func (mock *AccessorMock) GetCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Incr calls IncrFunc.
func (mock *AccessorMock) Incr(ctx context.Context, key string) (int64, error) {
	if mock.IncrFunc == nil {
		panic("AccessorMock.IncrFunc: method is nil but Accessor.Incr was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockIncr.Lock()
	mock.calls.Incr = append(mock.calls.Incr, callInfo)
	mock.lockIncr.Unlock()
	return mock.IncrFunc(ctx, key)
}

// IncrCalls gets all the calls that were made to Incr.
// Check the length with:
//
//	len(mockedAccessor.IncrCalls())
func (mock *AccessorMock) IncrCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockIncr.RLock()
	calls = mock.calls.Incr
	mock.lockIncr.RUnlock()
	return calls
}

// LPop calls LPopFunc.
func (mock *AccessorMock) LPop(ctx context.Context, key string) (any, error) {
	if mock.LPopFunc == nil {
		panic("AccessorMock.LPopFunc: method is nil but Accessor.LPop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockLPop.Lock()
	mock.calls.LPop = append(mock.calls.LPop, callInfo)
	mock.lockLPop.Unlock()
	return mock.LPopFunc(ctx, key)
}

// LPopCalls gets all the calls that were made to LPop.
// Check the length with:
//
//	len(mockedAccessor.LPopCalls())
func (mock *AccessorMock) LPopCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockLPop.RLock()
	calls = mock.calls.LPop
	mock.lockLPop.RUnlock()
	return calls
}

// LPush calls LPushFunc.
func (mock *AccessorMock) LPush(ctx context.Context, key string, value any) (any, error) {
	if mock.LPushFunc == nil {
		panic("AccessorMock.LPushFunc: method is nil but Accessor.LPush was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value any
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockLPush.Lock()
	mock.calls.LPush = append(mock.calls.LPush, callInfo)
	mock.lockLPush.Unlock()
	return mock.LPushFunc(ctx, key, value)
}

// LPushCalls gets all the calls that were made to LPush.
// Check the length with:
//
//	len(mockedAccessor.LPushCalls())
func (mock *AccessorMock) LPushCalls() []struct {
	Ctx   context.Context
	Key   string
	Value any
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value any
	}
	mock.lockLPush.RLock()
	calls = mock.calls.LPush
	mock.lockLPush.RUnlock()
	return calls
}

// RPop calls RPopFunc.
func (mock *AccessorMock) RPop(ctx context.Context, key string) (any, error) {
	if mock.RPopFunc == nil {
		panic("AccessorMock.RPopFunc: method is nil but Accessor.RPop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockRPop.Lock()
	mock.calls.RPop = append(mock.calls.RPop, callInfo)
	mock.lockRPop.Unlock()
	return mock.RPopFunc(ctx, key)
}

// RPopCalls gets all the calls that were made to RPop.
// Check the length with:
//
//	len(mockedAccessor.RPopCalls())
func (mock *AccessorMock) RPopCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockRPop.RLock()
	calls = mock.calls.RPop
	mock.lockRPop.RUnlock()
	return calls
}

// RPush calls RPushFunc.
func (mock *AccessorMock) RPush(ctx context.Context, key string, value any) (any, error) {
	if mock.RPushFunc == nil {
		panic("AccessorMock.RPushFunc: method is nil but Accessor.RPush was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value any
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockRPush.Lock()
	mock.calls.RPush = append(mock.calls.RPush, callInfo)
	mock.lockRPush.Unlock()
	return mock.RPushFunc(ctx, key, value)
}

// RPushCalls gets all the calls that were made to RPush.
// Check the length with:
//
//	len(mockedAccessor.RPushCalls())
func (mock *AccessorMock) RPushCalls() []struct {
	Ctx   context.Context
	Key   string
	Value any
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value any
	}
	mock.lockRPush.RLock()
	calls = mock.calls.RPush
	mock.lockRPush.RUnlock()
	return calls
}

// SAdd calls SAddFunc.
func (mock *AccessorMock) SAdd(ctx context.Context, key string, members ...any) (int64, error) {
	if mock.SAddFunc == nil {
		panic("AccessorMock.SAddFunc: method is nil but Accessor.SAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []any
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockSAdd.Lock()
	mock.calls.SAdd = append(mock.calls.SAdd, callInfo)
	mock.lockSAdd.Unlock()
	return mock.SAddFunc(ctx, key, members...)
}

// SAddCalls gets all the calls that were made to SAdd.
// Check the length with:
//
//	len(mockedAccessor.SAddCalls())
func (mock *AccessorMock) SAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []any
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []any
	}
	mock.lockSAdd.RLock()
	calls = mock.calls.SAdd
	mock.lockSAdd.RUnlock()
	return calls
}

// SRem calls SRemFunc.
func (mock *AccessorMock) SRem(ctx context.Context, key string, members ...any) (int64, error) {
	if mock.SRemFunc == nil {
		panic("AccessorMock.SRemFunc: method is nil but Accessor.SRem was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []any
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockSRem.Lock()
	mock.calls.SRem = append(mock.calls.SRem, callInfo)
	mock.lockSRem.Unlock()
	return mock.SRemFunc(ctx, key, members...)
}

// SRemCalls gets all the calls that were made to SRem.
// Check the length with:
//
//	len(mockedAccessor.SRemCalls())
func (mock *AccessorMock) SRemCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []any
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []any
	}
	mock.lockSRem.RLock()
	calls = mock.calls.SRem
	mock.lockSRem.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *AccessorMock) Set(ctx context.Context, key string, value any, exp time.Duration) (string, error) {
	if mock.SetFunc == nil {
		panic("AccessorMock.SetFunc: method is nil but Accessor.Set was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value any
		Exp   time.Duration
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
		Exp:   exp,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, key, value, exp)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedAccessor.SetCalls())
func (mock *AccessorMock) SetCalls() []struct {
	Ctx   context.Context
	Key   string
	Value any
	Exp   time.Duration
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value any
		Exp   time.Duration
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}
